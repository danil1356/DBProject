# DBProject
 1 .	Разработка схемы БД для реализации проекта
 1.1 .	Разработка логической схемы
Для проектирования базы данных необходимо составить логические и физические схемы БД. 
На рисунке 1 представлена логическая схема базы данных, спроектированная на платформе Erwin.
 
 ![image](https://user-images.githubusercontent.com/68468188/222906674-6b18f6a5-1c2b-4f07-bb9d-dd8378b2be9e.png)

Рисунок 1. Логическая схема БД.

Схема имеет следующие сущности:
1.	Клиент - контактная информация и информация необходимая для оформления рассрочки предоставляется в данной таблице.
2.	Документ рассрочки - представляет из себя совокупность значений клиента и значений магазина необходимые для рассрочки. Так же имеет собственные поля, в которых описывается: кол-во взятого товара, стоимость этого товара, и кол-во месяцев, предоставленных на выплату. 
3.	Магазин - имеет значение адреса магазина и вторичные ключи на товар и работников магазина.
4.	Работник - предоставляет информацию о работнике.
5.	Продукт - описывает продукт, продаваемый в магазине. Имеет поля цены и названия продукта. Так же у продукта имеется состав и поставщик оформленные отдельными таблицами.
6.	Состав - описывает множество составов одного продукта (Например, с сахаром или сахарозой и т.д.).
7.	Поставщик - описывает адрес поставщика для какой-либо компании.
8.	Компания - информация об производителе.

 1.2 .	Создание физической схемы
Отличие физической схемы от логической в том, что физическая описывает программируемую (типы данных, указание имен полей как в коде и т.д.) структуру базы данных, в то время как логическая описывает концептуальную логику проектируемой базы данных. Физическая база данных приведена на рисунке 2.
  
  ![image](https://user-images.githubusercontent.com/68468188/222906689-a9250f45-dc9e-4876-89ac-2a0da9369fa9.png)

Рисунок 2. Физическая схема БД.
 
 2 .	Создание скриптов для построения БД
Проектируемые нами ранее схемы в приложении Erwin поддерживают такую возможность как генерация кода по созданной схеме. Спроектированная нами физическая схема уже готова к реализации БД в выбранной нами СУБД Oracle SQL. Пример сгенерированного кода приведен ниже.
![image](https://user-images.githubusercontent.com/68468188/222906701-4994d7cf-28df-4137-abb4-936aa7b6e746.png)

 

Как мы видим, система сгенерировала нам таблицу по проектируемой из схемы с указанными нами типами данных и уникальными ключами.
 
 3 .	Создание встроенной функции генерации первичного ключа.
Проектируемая нами функция предоставляет функционал автоматической генерации первичного ключа для таблицы. Генерируемый функцией ключ будет иметь вид:
![image](https://user-images.githubusercontent.com/68468188/222906723-056324bf-8e55-4bf0-8f6f-427a109e2f92.png)

 
Где:
•	! – визуальный разделитель двух типов значений (может быть любым).
•	Значения слева от разделителя – код таблицы (трехзначный), инициализируется нами и записывается в таблицу SYS_OBJECT.
•	Значения справа от разделителя – уникальные значении последовательности (SEQUENCE), определенной для каждой таблицы.

Таблица SYS_OBJECT – таблица, содержащая в себе имя таблицы и ее id. Данная таблица будет содержать в себе имена необходимых нам таблиц, для которых мы в будущем будем генерировать ключи и имеет вид:
 ![image](https://user-images.githubusercontent.com/68468188/222906737-ede48c98-446d-4388-a7d4-113de26ce71d.png)

 
Заполнение таблицы происходит как средствами системы Oracle, так и вручную командами sql. В данном случае заполнение происходило с помощью Oracle.
![image](https://user-images.githubusercontent.com/68468188/222906744-ba9fa72e-98bd-4f77-8447-b1c173ef4e8a.png)

 
В таблицу заносятся имена необходимых таблиц и id. 
Далее нам необходимо создать последовательности для каждой необходимой таблицы с значениями: начало – 0, интервал – 1, максимальное значение – 999…. (не ограничено). Указать имя последовательности необходимо начав с SEC$.... после которого указывается название таблицы заглавными буквами без пробелов:
 ![image](https://user-images.githubusercontent.com/68468188/222906758-ab9096bd-8505-4dd3-b090-45a8eab06f8e.png)

Получая следующий пример: 
 ![image](https://user-images.githubusercontent.com/68468188/222906755-567f01c2-98f3-4c3f-b7ee-fb2e81c6e2ad.png)


После того как мы создали системную таблицу, в которой содержится id таблицы и все необходимые последовательности можно приступить к проектированию самой функции генерации. Пример части когда функции:
![image](https://user-images.githubusercontent.com/68468188/222906768-2f7d95f1-a3a8-4d66-8304-0e0b85b51ec2.png)

 
В качестве аргумента функция получает название таблицы, одно из тех, что мы добавили в sys_object. Возвращает функция нам уже первичный ключ. В функции предусмотрен набор цифр и латиница как заглавная, так и прописная для формирования значения ключа.
 
4.	Создание триггеров для проверки документов
4.1.	Проверка ИНН.
Для проверки вводимого ИНН используется триггер, отличие его от функции в том, что триггер вызывается сам при попытке изменения данных в таблице. Для вычисления корректности, введенного ИНН существуют правила проверки контрольных чисел:
1)	Контрольное число n1 вычисляется как остаток от деления на 11 суммы из цифр номера (по порядку слева направо), умноженных на соответствующие (приведенные выше) коэффициенты. Если в остатке получается 10, то n1 = 0. Полученное контрольное число n1 должно совпадать с последней цифрой ИНН (как 10-значного, так и 12-значного).
2)	Контрольное число n2 - это остаток от деления на 11 суммы из цифр номера, умноженных на соответствующие коэффициенты (аналогично шагу 1). Если в остатке получается 10, то n2 = 0. Полученное контрольное число n2 должно совпадать с предпоследней цифрой 12-значного ИНН.

Фрагмент кода триггера проверки ИНН представлен ниже.
![image](https://user-images.githubusercontent.com/68468188/222906778-e1645130-a1e3-46b1-b20d-459ca4b326ba.png)
![image](https://user-images.githubusercontent.com/68468188/222906783-5a79246f-2cc2-4b0b-ae9e-c95018eb9eda.png)

 

 
4.2.	Проверка СНИЛС
СНИЛС имеет вид "XXX-XXX-XXX YY", где XXX-XXX-XXX - номер, а YY - контрольное число.
Проверка контрольного числа имеет несколько правил:
1.	Каждая цифра СНИЛС умножается на номер своей позиции (позиции отсчитываются с конца); Полученные произведения суммируются;  Если сумма меньше 100, то контрольное число равно самой сумме;  Если сумма равна 100 или 101, то контрольное число равно 00; Если сумма больше 101, то сумма делится нацело на 101
2.	В номере XXX-XXX-XXX не может присутствовать одна и та же цифра три раза подряд.
Пример кода триггера для проверки СНИЛС представлен ниже.
 ![image](https://user-images.githubusercontent.com/68468188/222906794-18350018-290e-430c-8ff0-23383d3f19f1.png)

   ![image](https://user-images.githubusercontent.com/68468188/222906802-1ef5a00c-20cb-4006-a4d1-191e6fbaf681.png)

![image](https://user-images.githubusercontent.com/68468188/222906805-e268af99-62ad-4d74-a84f-0c3140fd353c.png)

 
5.	Триггер для проверки бизнес правил.
Предусмотрим, что системой будет отказано в получении рассрочки, когда клиент имеет непогашенные рассрочки суммарно на 100 000р. 
 
Данный триггер в начале проверяет, что данные по кол-ву продукта и цене продукта введены. Далее происходит суммирование всех рассрочек, взятых конкретным клиентом, в данном случае клиентом который собирается взять новую или еще не брал ни одной. Для клиента, который еще не брал рассрочку, предусмотрено исключение если вдруг в базе данных еще нет информации о его рассрочках.
 
6.	Создание протокола изменений
Протоколирование совершенных изменений в базе данных одна из важных частей целостности БД. Любое изменение данных необходимо фиксировать, если мы хотим знать кто, что и когда изменил. Так у нас будет полное представление об изменениях данных.

Все совершенные нами изменения будут хранится в одной таблице sys_protokol. Данная таблица содержит в себе свой id, название таблицы, название столбца, новое значение и старое, дата изменения, имя внесшего изменения, тип выполненной операции (insert, delete update) и id первичный ключ изменяемого объекта. Для таблицы так же генерируется первичный ключ как и для остальных таблиц в базе данных.

Пример кода создания таблицы sys_protokol:
 

В таблицу триггеры реагируя на изменения записывают результат.
Для каждой таблицы, изменения значения которой мы хотим отслеживать, необходимо написать триггер. 
Пример триггера: 
 
Данный триггер определяет тип проводимой операции и в зависимости от типа операции протоколирует действие в соответствующую таблицу. 
Пример записанной информации:
 



